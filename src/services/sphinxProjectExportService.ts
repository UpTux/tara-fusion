import JSZip from 'jszip';
import { AttackPotentialTuple, NeedType, Project, RiskTreatmentDecision } from '../types';
import { calculateAP, calculateHighestImpact, calculateRiskLevel, getAttackFeasibilityRating } from './riskService';

const rstHeader = (title: string, level: number): string => {
    const underlines = ['=', '-', '`', ':', '.', "'", '"', '~', '^', '_', '*', '+', '#', '<', '>'];
    if (level < 0 || level >= underlines.length) {
        level = 0;
    }
    return `${title}\n${underlines[level].repeat(title.length)}\n\n`;
};

const rstListTable = (headers: string[], rows: string[][], title?: string, widths?: number[]): string => {
    let rst = title ? `.. list-table:: ${title}\n` : `.. list-table::\n`;
    rst += `   :header-rows: 1\n`;
    if (widths) {
        rst += `   :widths: ${widths.join(' ')}\n`;
    }
    rst += `\n`;

    rst += `   * - ${headers.join('\n     - ')}\n`;

    rows.forEach(row => {
        rst += `   * - ${row.join('\n     - ')}\n`;
    });

    return rst + '\n';
};

const toSnakeCase = (str: string) => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);

const generateNeedRst = (needData: { [key: string]: any }, type: string, title: string, id: string, description: string): string => {
    let content = `.. ${type}:: ${title}\n`;
    content += `   :id: ${id}\n`;

    const excludeFields = new Set(['id', 'type', 'title', 'description', 'position', 'name', 'comment']);

    for (const key of Object.keys(needData)) {
        if (excludeFields.has(key)) continue;

        const value = needData[key];
        if (value === undefined || value === null) continue;

        const snakeKey = toSnakeCase(key);

        if (Array.isArray(value)) {
            if (value.length > 0) {
                content += `   :${snakeKey}: ${value.join(', ')}\n`;
            }
        } else if (typeof value === 'object') {
            if (key === 'attackPotential' && value) {
                const ap = value as AttackPotentialTuple;
                const apValues = Object.entries(ap).map(([k, v]) => `${k}:${v}`).join('; ');
                content += `   :attack_potential: ${apValues}\n`;
            }
        }
        else if (value !== '' && typeof value !== 'boolean') {
            content += `   :${snakeKey}: ${value}\n`;
        }
        else if (typeof value === 'boolean') {
            content += `   :${snakeKey}: ${value ? 'True' : 'False'}\n`;
        }
    }

    const cleanedDescription = description && description.trim().length > 0 ? description : 'No description provided.';
    content += `\n   ${cleanedDescription.replace(/\n/g, '\n   ')}\n\n`;
    return content;
};


const generatePyProjectToml = (): string => `
[project]
name = "tara-sphinx-export"
version = "1.0.0"
description = "TARA project documentation generated by TARA Fusion."
dependencies = [
    "sphinx[test]>=8.2.3",
    "sphinx-needs[plotting]==6.0.1",  # pin as RTD consumes this file, not uv.lock
    "sphinxcontrib-plantuml>=0.30",
    "sphinx-design>=0.6.1",
    "sphinx-simplepdf>=1.6.0",
    "sphinx-test-reports==1.3.1",  # pin as RTD consumes this file, not uv.lock
    "furo>=2024.8.6",
    "sphinx-preview>=0.1.2",
    "sphinx-immaterial>=0.13.6",
]
requires-python = "==3.12.*"
`;

const generateConfPy = (projectName: string): string => `
# Configuration file for the Sphinx documentation builder.
project = '${projectName.replace(/'/g, "\\'")}'
copyright = '2025, TARA Fusion Export'
author = 'TARA Fusion'

extensions = [
    "sphinx_needs",
    "sphinx_design",
    "sphinxcontrib.plantuml",
    "sphinxcontrib.test_reports",
    "sphinx_simplepdf",
    "sphinx.ext.autodoc",
    "sphinx.ext.viewcode",
    "sphinx_preview",
]

# Tell sphinx-plantuml where to find the JAR file
# USER ACTION: You may need to update this path to point to your plantuml.jar file
# You can download it from: https://plantuml.com/download
# Example: plantuml = 'java -jar /path/to/plantuml.jar'
plantuml_output_format = 'svg'


templates_path = ['_templates']
exclude_patterns = []

html_theme = 'furo'
html_static_path = ['_static', '_image']

# Sphinx-Needs configuration
needs_types = [
    dict(directive="req", title="Requirement", prefix="R_", color="#BFD8D2", style="node"),
    dict(directive="spec", title="Specification", prefix="S_", color="#FEDCD2", style="node"),
    dict(directive="impl", title="Implementation", prefix="I_", color="#DF744A", style="node"),
    dict(directive="test", title="Test Case", prefix="T_", color="#DCB239", style="node"),
    dict(directive="feat", title="Feature", prefix="F_", color="#8ac354", style="node"),
    dict(directive="need", title="Need", prefix="N_", color="#666666", style="node"),
    dict(directive="issue", title="Issue", prefix="ISS_", color="#959045", style="node"),
    dict(directive="risk", title="Risk", prefix="RISK_", color="#E6B333", style="node"),
    dict(directive="action", title="Action", prefix="ACT_", color="#459074", style="node"),
    dict(directive="attack", title="Attack Step", prefix="ATT_", color="#FF6666", style="node"),
    # TARA types
    dict(directive="ass", title="Assumption", prefix="ASS_", color="#FFC107", style="node"),
    dict(directive="asset", title="Asset", prefix="ASSET_", color="#A9A9A9", style="node"),
    dict(directive="sc", title="Security Control", prefix="SC_", color="#9C27B0", style="node"),
    dict(directive="ds", title="Damage Scenario", prefix="DS_", color="#CD5C5C", style="node"),
    dict(directive="threat", title="Threat", prefix="THR_", color="#F29379", style="node"),
    dict(directive="ts", title="Threat Scenario", prefix="TS_", color="#FFA07A", style="node"),
    dict(directive="sg", title="Security Goal", prefix="SG_", color="#4CAF50", style="node"),
    dict(directive="scl", title="Security Claim", prefix="SCLM_", color="#2196F3", style="node"),
]

needs_extra_options = [
    'active',
    'active_r_r_a',
    'asset_id',
    'assumption_ids',
    'attack_potential',
    'attacker_type',
    'comment',
    'damage_scenario_ids',
    'impact',
    'impact_category',
    'initial_a_f_r',
    'knowledge',
    'logic_gate',
    'misuse_case_ids',
    'reasoning',
    'reasoning_scaling',
    'requirements_link',
    'residual_a_f_r',
    'responsible',
    'scales',
    'security_claim_ids',
    'security_control_id',
    'security_goal_ids',
    'security_properties',
    'threat_id',
    'toe_configuration_ids',
    'treatment_decision',
]
`;

const generateIndexRst = (projectName: string): string => `
${rstHeader(projectName, 0)}

This document is an export of a TARA project generated by TARA Fusion.

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   01_project_meta
   02_scope_and_assumptions
   03_system_definition
   04_threat_analysis
   05_attack_trees
   06_risk_treatment
`;

const generateProjectMetaRst = (project: Project): string => {
    let content = rstHeader('Project Metadata', 0);
    content += `* **Security Manager**: ${project.securityManager || 'N/A'}\n`;
    content += `* **Project Status**: ${project.projectStatus || 'N/A'}\n\n`;
    if (project.comment) {
        content += rstHeader('Comment', 1);
        content += `${project.comment}\n\n`;
    }
    return content;
};

const generateScopeAndAssumptionsRst = (project: Project): string => {
    let content = rstHeader('Scope and Assumptions', 0);
    if (project.toeDescription) {
        content += rstHeader('TOE Description', 1);
        content += `${project.toeDescription}\n\n`;
    }
    if (project.scope) {
        content += rstHeader('Scope', 1);
        content += `${project.scope}\n\n`;
    }
    if (project.assumptions && project.assumptions.length > 0) {
        content += rstHeader('Assumptions', 1);
        project.assumptions.forEach(a => {
            content += generateNeedRst(a, 'ass', a.name, a.id, a.comment);
        });
    }
    return content;
};

const generateSystemDefRst = (project: Project): string => {
    let content = rstHeader('System Definition', 0);
    if (project.toeConfigurations && project.toeConfigurations.length > 0) {
        content += rstHeader('TOE Configurations', 1);
        const headers = ['ID', 'Name', 'Active', 'Description'];
        const rows = project.toeConfigurations.map(c => [c.id, c.name, c.active ? 'Yes' : 'No', c.description]);
        content += rstListTable(headers, rows);
    }
    if (project.assets && project.assets.length > 0) {
        content += rstHeader('Assets', 1);
        project.assets.forEach(a => {
            const desc = `${a.description}\n\n**Comment:** ${a.comment}`;
            content += generateNeedRst(a, 'asset', a.name, a.id, desc);
        });
    }
    if (project.securityControls && project.securityControls.length > 0) {
        content += rstHeader('Security Controls', 1);
        project.securityControls.forEach(sc => {
            const desc = `${sc.description}\n\n**Comment:** ${sc.comment}`;
            content += generateNeedRst(sc, 'sc', sc.name, sc.id, desc);
        });
    }
    return content;
};

const generateThreatAnalysisRst = (project: Project): string => {
    let content = rstHeader('Threat Analysis', 0);
    if (project.damageScenarios && project.damageScenarios.length > 0) {
        content += rstHeader('Damage Scenarios', 1);
        project.damageScenarios.forEach(ds => {
            const desc = `${ds.description}\n\n**Reasoning:**\n${ds.reasoning}\n\n**Comment:**\n${ds.comment}`;
            content += generateNeedRst(ds, 'ds', ds.name, ds.id, desc);
        });
    }
    if (project.threats && project.threats.length > 0) {
        content += rstHeader('Threats', 1);
        project.threats.forEach(t => {
            const desc = `${t.comment}\n\n**Reasoning for scaling:**\n${t.reasoningScaling}`;
            content += generateNeedRst(t, 'threat', t.name, t.id, desc);
        });
    }
    if (project.threatScenarios && project.threatScenarios.length > 0) {
        content += rstHeader('Threat Scenarios', 1);
        project.threatScenarios.forEach(ts => {
            const desc = `${ts.description}\n\n**Comment:**\n${ts.comment}`;
            content += generateNeedRst(ts, 'ts', ts.name, ts.id, desc);
        });
    }
    return content;
};

const generateAttackTreesRst = (project: Project): string => {
    let content = rstHeader('Attack Trees', 0);
    const attackTreeRoots = project.needs.filter(n => n.type === NeedType.ATTACK && (n.tags.includes('attack-root') || n.tags.includes('circumvent-root')));

    if (attackTreeRoots.length === 0) {
        content += "No attack trees found in the project.\n";
        return content;
    }

    const needsMap = new Map(project.needs.map(n => [n.id, n]));

    attackTreeRoots.forEach(root => {
        content += rstHeader(`Tree: ${root.title} (${root.id})`, 1);

        const treeNodeIds = new Set<string>();
        const queue: string[] = [root.id];
        treeNodeIds.add(root.id);
        while (queue.length > 0) {
            const currentId = queue.shift();
            if (!currentId) continue;
            const currentNode = needsMap.get(currentId);
            if (currentNode?.links) {
                for (const link of currentNode.links) {
                    if (needsMap.has(link) && !treeNodeIds.has(link)) {
                        treeNodeIds.add(link);
                        queue.push(link);
                    }
                }
            }
        }

        // Add image directive
        content += `.. image:: /_image/attack_tree_${root.id}.png\n`;
        content += `   :alt: Attack Tree for ${root.id}\n`;
        content += `   :align: center\n`;
        content += `   :width: 100%\n\n`;

        // Add table of nodes
        content += `.. needtable::\n`;
        content += `   :ids: ${Array.from(treeNodeIds).join(',')}\n`;
        content += `   :columns: id, title, type, logic_gate\n`;
        content += `   :caption: Nodes for tree ${root.id}\n\n`;
    });

    return content;
};

const generateRiskTreatmentRst = (project: Project): string => {
    let content = rstHeader('Risk Treatment', 0);
    if (project.securityGoals && project.securityGoals.length > 0) {
        content += rstHeader('Security Goals', 1);
        project.securityGoals.forEach(sg => {
            content += generateNeedRst(sg, 'sg', sg.name, sg.id, sg.comment);
        });
    }
    if (project.securityClaims && project.securityClaims.length > 0) {
        content += rstHeader('Security Claims', 1);
        project.securityClaims.forEach(sc => {
            content += generateNeedRst(sc, 'scl', sc.name, sc.id, sc.comment);
        });
    }

    const scenariosWithRisk = (project.threatScenarios || []).map(ts => {
        const impact = calculateHighestImpact(ts.damageScenarioIds, project.damageScenarios || []);
        const ap = calculateAP(ts.attackPotential);
        const rating = getAttackFeasibilityRating(ap);
        const risk = calculateRiskLevel(rating, impact);
        return { ...ts, risk };
    });

    if (scenariosWithRisk.length > 0) {
        content += rstHeader('Risk Treatment Decisions', 1);
        const headers = ['Threat Scenario', 'Risk Level', 'Decision', 'Mitigation/Justification'];
        const rows = scenariosWithRisk.map(ts => {
            let mitigation = '';
            if (ts.treatmentDecision === RiskTreatmentDecision.REDUCE) {
                mitigation = (ts.securityGoalIds || []).map(id => `:need:\`${id}\``).join(', ');
            } else if (ts.treatmentDecision === RiskTreatmentDecision.ACCEPT || ts.treatmentDecision === RiskTreatmentDecision.TRANSFER) {
                mitigation = (ts.securityClaimIds || []).map(id => `:need:\`${id}\``).join(', ');
            }
            return [`:need:\`${ts.id}\``, ts.risk, ts.treatmentDecision || 'TBD', mitigation];
        });
        content += rstListTable(headers, rows, undefined, [30, 15, 15, 40]);
    }

    return content;
}

export async function exportProjectToSphinxZip(project: Project, images: Map<string, string>): Promise<Blob> {
    const zip = new JSZip();

    zip.file('pyproject.toml', generatePyProjectToml());
    zip.file('source/conf.py', generateConfPy(project.name));

    const source = zip.folder('source');
    if (!source) throw new Error("Could not create source folder in zip.");

    source.file('index.rst', generateIndexRst(project.name));
    source.file('01_project_meta.rst', generateProjectMetaRst(project));
    source.file('02_scope_and_assumptions.rst', generateScopeAndAssumptionsRst(project));
    source.file('03_system_definition.rst', generateSystemDefRst(project));
    source.file('04_threat_analysis.rst', generateThreatAnalysisRst(project));
    source.file('05_attack_trees.rst', generateAttackTreesRst(project));
    source.file('06_risk_treatment.rst', generateRiskTreatmentRst(project));

    const imageFolder = source.folder('_image');
    if (!imageFolder) throw new Error("Could not create _image folder in zip.");

    for (const [rootId, dataUrl] of images.entries()) {
        const base64Data = dataUrl.replace(/^data:image\/png;base64,/, "");
        imageFolder.file(`attack_tree_${rootId}.png`, base64Data, { base64: true });
    }

    source.folder('_static');
    source.folder('_templates');

    const blob = await zip.generateAsync({ type: 'blob' });
    return blob;
}